/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 */

function formatScheduleData(rawData) {
    if (!rawData || !rawData.scores || !rawData.scores.category) {
        return { error: "Invalid or missing data structure" };
    }

    const scheduleData = {
        league: "CFL",
        upcoming_games: []
    };

    const MAX_GAMES = 10;
    let gamesCount = 0;

    // category can be array or single object
    const categories = Array.isArray(rawData.scores.category)
        ? rawData.scores.category
        : [rawData.scores.category];

    for (const category of categories) {
        if (category.match && Array.isArray(category.match)) {
            for (const match of category.match) {
                if (gamesCount >= MAX_GAMES) break;
                if (match.status === "Not Started") {
                    scheduleData.upcoming_games.push({
                        date: match.date || null,
                        time: match.time || null,
                        home_team: match.localteam?.name || null,
                        away_team: match.awayteam?.name || null,
                        match_id: match.id || null,
                        venue: match.venue_name || null
                    });
                    gamesCount++;
                }
            }
        }
    }

    return scheduleData;
}

function formatStandingsData(rawData) {
    if (!rawData || !rawData.category) {
        return { error: "Invalid or missing standings data structure" };
    }

    const formattedStandings = {
        league: rawData.category['@name'],
        season: rawData.category['@season'],
        sport: rawData['@sport'],
        conferences: []
    };

    // Process each conference (e.g., American League/National League for MLB)
    if (rawData.category.league && Array.isArray(rawData.category.league)) {
        rawData.category.league.forEach(conference => {
            const formattedConference = {
                name: conference['@name'],
                divisions: []
            };
            // Process each division in the conference
            if (conference.division && Array.isArray(conference.division)) {
                conference.division.forEach(division => {
                    const formattedDivision = {
                        name: division['@name'],
                        teams: []
                    };
                    // Process each team in the division
                    if (division.team && Array.isArray(division.team)) {
                        division.team.forEach(team => {
                            // Include only the most relevant fields for predictions
                            formattedDivision.teams.push({
                                name: team['@name'],
                                position: team['@position'],
                                won: team['@won'],
                                lost: team['@lost'],
                                home_record: team['@home_record'],
                                road_record: team['@away_record'],
                                points_for: team['@runs_scored'] || team['@points_for'],
                                points_against: team['@runs_allowed'] || team['@points_against'],
                                difference: team['@runs_diff'] || team['@difference'],
                                streak: team['@current_streak'] || team['@streak'],
                                games_back: team['@games_back']
                            });
                        });
                    }
                    formattedConference.divisions.push(formattedDivision);
                });
            }
            formattedStandings.conferences.push(formattedConference);
        });
    }

    return formattedStandings;
}

function formatScoresData(rawData) {
     if (!rawData || !rawData.scores || !rawData.scores.category) {
        return { error: "Invalid or missing data structure" };
    }

    const scheduleData = {
        league: rawData.scores.sport || "football",
        upcoming_games: []
    };

    const MAX_GAMES = 10;
    let gamesCount = 0;

    // category can be array or single object
    const categories = Array.isArray(rawData.scores.category)
        ? rawData.scores.category
        : [rawData.scores.category];

    for (const category of categories) {
        // match can be array or single object
        if (category.match) {
            const matches = Array.isArray(category.match)
                ? category.match
                : [category.match];

            for (const match of matches) {
                if (gamesCount >= MAX_GAMES) break;
                if (match.status === "Not Started") {
                    scheduleData.upcoming_games.push({
                        date: match.date || null,
                        time: match.time || null,
                        home_team: match.localteam?.name || null,
                        away_team: match.awayteam?.name || null,
                        match_id: match.id || null,
                        league_name: category.name || null
                    });
                    gamesCount++;
                }
            }
        }
    }

    // Limit the stringified scheduleData to 25,000 characters (cut from the beginning)
    const MAX_SCHEDULE_LENGTH = 25000;
    let scheduleStr = JSON.stringify(scheduleData);
    if (scheduleStr.length > MAX_SCHEDULE_LENGTH) {
        scheduleStr = scheduleStr.slice(scheduleStr.length - MAX_SCHEDULE_LENGTH);
        try {
            return JSON.parse(scheduleStr);
        } catch (e) {
            return { error: "Schedule data truncated and could not be parsed as JSON." };
        }
    }

    return scheduleData;
}


function formatCFLData(rawData) {
    console.log(rawData)
    return {
        schedule: formatScheduleData(rawData.schedule),
        standings: '',
        scores: ''
    }
}

module.exports = {
    formatCFLData
};
