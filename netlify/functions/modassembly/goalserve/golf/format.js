/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 */

function formatScheduleData(rawData) {
     if (!rawData || !rawData || !rawData.tournament) {
        return { error: "Invalid or missing schedules data structure" };
    }

    const tournaments = Array.isArray(rawData.tournament)
        ? rawData.tournament
        : [rawData.tournament];

    const formatted = {
        sport: rawData.sport,
        season: rawData.season,
        series: rawData.series,
        tournaments: []
    };

    tournaments.forEach(tournament => {
        formatted.tournaments.push({
            id: tournament.id,
            name: tournament.name,
            location: tournament.location,
            date_start: tournament.date_start,
            date_end: tournament.date_end,
            purse: tournament.purse,
            winner: tournament.winner,
            winner_id: tournament.winner_id
        });
    });

    return formatted;
}

function formatStandingsData(rawData) {
    if (!rawData || !rawData.category) {
        return { error: "Invalid or missing standings data structure" };
    }

    const formattedStandings = {
        league: rawData.category['@name'],
        season: rawData.category['@season'],
        sport: rawData['@sport'],
        conferences: []
    };

    // Process each conference (e.g., American League/National League for MLB)
    if (rawData.category.league && Array.isArray(rawData.category.league)) {
        rawData.category.league.forEach(conference => {
            const formattedConference = {
                name: conference['@name'],
                divisions: []
            };
            // Process each division in the conference
            if (conference.division && Array.isArray(conference.division)) {
                conference.division.forEach(division => {
                    const formattedDivision = {
                        name: division['@name'],
                        teams: []
                    };
                    // Process each team in the division
                    if (division.team && Array.isArray(division.team)) {
                        division.team.forEach(team => {
                            // Include only the most relevant fields for predictions
                            formattedDivision.teams.push({
                                name: team['@name'],
                                position: team['@position'],
                                won: team['@won'],
                                lost: team['@lost'],
                                home_record: team['@home_record'],
                                road_record: team['@away_record'],
                                points_for: team['@runs_scored'] || team['@points_for'],
                                points_against: team['@runs_allowed'] || team['@points_against'],
                                difference: team['@runs_diff'] || team['@difference'],
                                streak: team['@current_streak'] || team['@streak'],
                                games_back: team['@games_back']
                            });
                        });
                    }
                    formattedConference.divisions.push(formattedDivision);
                });
            }
            formattedStandings.conferences.push(formattedConference);
        });
    }

    return formattedStandings;
}

function formatScoresData(rawData) {
       if (!rawData || !rawData.scores || !rawData.scores.tournament) {
        return { error: "Invalid or missing scores data structure" };
    }

    const tournament = rawData.scores.tournament;
    const players = Array.isArray(tournament.player) ? tournament.player : [tournament.player];

    const formatted = {
        sport: rawData.scores.sport || 'golf',
        tournament: {
            id: tournament.id,
            name: tournament.name,
            country: tournament.country,
            end_date: tournament.end_date,
            gender: tournament.gender,
            par: tournament.par
        },
        leaderboard: []
    };

    players.forEach(player => {
        // Parse rounds
        let rounds = [];
        if (player.rounds && player.rounds.round) {
            rounds = Array.isArray(player.rounds.round) ? player.rounds.round : [player.rounds.round];
        }

        // Parse per-hole stats for each round (if available)
        let roundStats = [];
        if (player.stats && player.stats.rounds && player.stats.rounds.round) {
            const statsRounds = Array.isArray(player.stats.rounds.round) ? player.stats.rounds.round : [player.stats.rounds.round];
            roundStats = statsRounds.map(r => ({
                number: r.number,
                holes: r.hole ? (Array.isArray(r.hole) ? r.hole : [r.hole]) : []
            }));
        }

        formatted.leaderboard.push({
            id: player.id,
            name: player.name,
            pos: player.pos,
            par: player.par,
            scoreToPar: player.scoreToPar,
            today: player.today,
            total: player.total,
            hole: player.hole,
            rounds: rounds.map(r => ({
                number: r.number,
                result: r.result
            })),
            roundStats: roundStats,
            stats: {
                birdies: parseInt(player.birdies) || 0,
                bogeys: parseInt(player.bogeys) || 0,
                doubles: parseInt(player.doubles) || 0,
                eagles: parseInt(player.eagles) || 0,
                gir: parseFloat(player.gir) || 0,
                driveAccuracyPct: parseFloat(player.driveAccuracyPct) || 0,
                driveDistAvg: parseFloat(player.driveDistAvg) || 0,
                puttsGirAvg: parseFloat(player.puttsGirAvg) || 0,
                saves: player.saves,
                extra_stats: player.extra_stats
            }
        });
    });

    return formatted;
}


function formatGOLFData(rawData) {
    return {
        schedule: formatScheduleData(rawData.schedule),
        standings: '',
        scores: formatScoresData(rawData.scores)
    }
}

module.exports = {
    formatGOLFData
};
