/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 */

function formatScheduleData(rawData) {
    if (!rawData) {
        return { error: "Invalid or missing data structure" };
    }

    const scheduleData = {
        league: rawData['@sport'],
        season: rawData.category['@season'],
        upcoming_games: []
    };

    const upcomingGamesLimit = 15;

    // Check if matches exists
    if (rawData.category.matches) {
        // Handle both array of match days and single match day object
        const matchDays = Array.isArray(rawData.category.matches)
            ? rawData.category.matches
            : [rawData.category.matches];

        // Process each match day
        matchDays.forEach(matchDay => {
            if (matchDay.match && Array.isArray(matchDay.match)) {
                // Process all matches for a given day
                matchDay.match.forEach(match => {
                    // Only include upcoming games (status "Not Started")
                    // And limit to first 10 games
                    if (match['@status'] === "Not Started" && scheduleData.upcoming_games.length < upcomingGamesLimit) {
                        scheduleData.upcoming_games.push({
                            id: match['@id'],
                            d: match['@formatted_date'],
                            t: match['@time'],
                            ht: match.hometeam['@name'],
                            at: match.awayteam['@name'],
                            tn: rawData.category['@name'],
                            v: match['@venue_name'],
                        });
                    }
                });
            }
        });
    }

    return scheduleData;
}

function formatStandingsData(rawData) {
    if (!rawData || !rawData.category) {
        return { error: "Invalid or missing standings data structure" };
    }

    const formattedStandings = {
        league: rawData.category['@name'],
        season: rawData.category['@season'],
        sport: rawData['@sport'],
        conferences: []
    };

    // Process each conference (e.g., American League/National League for MLB)
    if (rawData.category.league && Array.isArray(rawData.category.league)) {
        rawData.category.league.forEach(conference => {
            const formattedConference = {
                name: conference['@name'],
                divisions: []
            };
            // Process each division in the conference
            if (conference.division && Array.isArray(conference.division)) {
                conference.division.forEach(division => {
                    const formattedDivision = {
                        name: division['@name'],
                        teams: []
                    };
                    // Process each team in the division
                    if (division.team && Array.isArray(division.team)) {
                        division.team.forEach(team => {
                            // Include only the most relevant fields for predictions
                            formattedDivision.teams.push({
                                n: team['@name'],
                                p: team['@position'],
                                w: team['@won'],
                                l: team['@lost'],
                                hr: team['@home_record'],
                                rr: team['@away_record'],
                                pf: team['@runs_scored'] || team['@points_for'],
                                pa: team['@runs_allowed'] || team['@points_against'],
                                diff: team['@runs_diff'] || team['@difference'],
                                strk: team['@current_streak'] || team['@streak'],
                                gb: team['@games_back']
                            });
                        });
                    }
                    formattedConference.divisions.push(formattedDivision);
                });
            }
            formattedStandings.conferences.push(formattedConference);
        });
    }

    return formattedStandings;
}

function formatScoresData(rawData) {
    if (!rawData || !rawData.scores) {
        return { error: "Invalid or missing scores data structure" };
    }

    // Initialize results
    const scoresData = {
        teams: {},
        metadata: {}
    }

    // Set limit for scoresData items
    let itemCount = 0;

    // Handle rawData.scores as an array
    const scoresArray = Array.isArray(rawData.scores) ? rawData.scores : [rawData.scores];

    for (const scoreItem of scoresArray) {
        // Handle both array and single match cases for each score item
        const matches = scoreItem.scores.category && scoreItem.scores.category.match
            ? (Array.isArray(scoreItem.scores.category.match)
                ? scoreItem.scores.category.match
                : [scoreItem.scores.category.match])
            : [];

        for (const match of matches) {
            // Compute home team
            if (match.hometeam) {
                const homeTeamId = match.hometeam['@name'];
                if (!scoresData.teams[homeTeamId]) {
                    scoresData.teams[homeTeamId] = [];

                    const homeTeamObj =  {
                        match: match['@id'],
                        stats: {
                            hits: parseInt(match.hometeam['@hits']) || 0,
                            errors: parseInt(match.hometeam['@errors']) || 0,
                            totalscore: parseInt(match.hometeam['@totalscore']) || 0,
                        },
                        players: {}
                    };
                    scoresData.teams[homeTeamId].push(homeTeamObj);
                    itemCount++;
                }

            }

            // Compute away team
            if (match.awayteam) {
                const awayTeamId = match.awayteam['@name'];
                if (!scoresData.teams[awayTeamId]) {
                    scoresData.teams[awayTeamId] = [];

                    const awayTeamObj =  {
                        stats: {
                            hits: parseInt(match.awayteam['@hits']) || 0,
                            errors: parseInt(match.awayteam['@errors']) || 0,
                            totalscore: parseInt(match.awayteam['@totalscore']) || 0,
                        },
                        players: {}
                    };
                    scoresData.teams[awayTeamId].push(awayTeamObj);
                    itemCount++;
                }
            }

            if (match.events) {
                // Process baseball events
                const processEvents = (events) => {
                    if (!events) return;

                    // Handle both single events and arrays of events
                    const eventArray = Array.isArray(events.event) ? events.event : [events.event];

                    eventArray.forEach(evt => {
                        if (!evt || !evt['@desc']) return;

                        // Extract player name from event description
                        const nameRegex = /([A-Z][a-zA-Z.'\-]+(?:\s[A-Z][a-zA-Z.'\-]+)*?(?:\sJr\.| Sr\.| III| II)?)/g;
                        const playerMatches = evt['@desc'].match(nameRegex) || [];
                        const playerTeamId = evt['@team'] == "awayteam" ? match.awayteam["@name"] : match.hometeam["@name"];

                        // Check if team exists before processing players
                        const length = scoresData.teams[playerTeamId].length
                        if (!playerTeamId || !scoresData.teams[playerTeamId][length - 1]) {
                            console.warn(`Team not found for playerTeamId: ${playerTeamId}`);
                            return;
                        }

                        playerMatches.forEach(playerId => {
                            if (!playerId) return;

                            let matchteam = scoresData.teams[playerTeamId][scoresData.teams[playerTeamId].length - 1];
                            // Initialize player if not exists under the team
                            if (!matchteam.players[playerId]) {
                                matchteam.players[playerId] = {
                                    home_runs: 0,
                                    singles: 0,
                                    doubles: 0,
                                    rbi: 0
                                };
                            }

                            // Update player statistics based on event description
                            const playerStats = matchteam.players[playerId];
                            if (evt['@desc'].includes('homered')) {
                                playerStats.home_runs++;
                            } else if (evt['@desc'].includes('doubled')) {
                                playerStats.doubles++;
                            } else if (evt['@desc'].includes('singled')) {
                                playerStats.singles++;
                            }

                            // Count RBIs
                            const rbiMatch = evt['@desc'].match(/scored(?: and [A-Za-z\-]+ scored)*(?:,|\.)/);
                            if (rbiMatch) {
                                const scorers = (rbiMatch[0].match(/[A-Za-z\-]+/g) || []).length;
                                playerStats.rbi += scorers;
                            }
                        });
                    });
                };

                processEvents(match.events);
            }
        }
    }

    // Add metadata about the limit
    scoresData.metadata = {
        totalItems: itemCount,
    };

    return scoresData;
}

// Function to compress scoresData for OpenAI prompts
function compressScoresDataForOpenAI(scoresData, maxCharacters = 25000) {
    if (!scoresData || scoresData.error) {
        return scoresData;
    }

    // Create compressed version
    const compressed = {
        t: {}, // teams
        m: scoresData.metadata // metadata
    };

    // Compress teams and their players
    Object.keys(scoresData.teams).forEach(teamId => {
        // Each teamId is now an array of team objects (one per match)
        compressed.t[teamId] = [];
        scoresData.teams[teamId].forEach(teamObj => {
            const compressedTeam = {
                m: teamObj.match,
                h: teamObj.stats.hits, // hits
                e: teamObj.stats.errors, // errors
                s: teamObj.stats.totalscore, // score
                p: {}
            };
            // Only include players with meaningful stats
            Object.keys(teamObj.players).forEach(playerId => {
                const player = teamObj.players[playerId];
                const totalStats = player.home_runs + player.singles + player.doubles + player.rbi;
                if (totalStats > 0) {
                    compressedTeam.p[playerId] = {
                        hr: player.home_runs, // home_runs
                        s: player.singles,    // singles
                        d: player.doubles,    // doubles
                        r: player.rbi         // rbi
                    };
                }
            });
            compressed.t[teamId].push(compressedTeam);
        });
    });

    // Check character count and further compress if needed
    const jsonString = JSON.stringify(compressed);
    console.log(jsonString.length)
    if (jsonString.length > maxCharacters) {
        // Optionally, call compressScoresDataForOpenAIAdvanced or fallback
        return compressed;
    }

    return compressed;
}

// Advanced compression for very large datasets
function compressScoresDataForOpenAIAdvanced(scoresData, maxCharacters = 25000) {
    if (!scoresData || scoresData.error) {
        return scoresData;
    }

    // Sort teams by total score (descending) and keep top 50 teams (across all matches)
    const teamTotals = Object.entries(scoresData.teams).map(([teamId, teamArr]) => {
        // Sum total scores across all matches for this team
        const totalScore = teamArr.reduce((sum, teamObjWithId) => {
            const matchId = Object.keys(teamObjWithId)[0];
            const teamObj = teamObjWithId[matchId];
            return sum + (teamObj.stats.totalscore || 0);
        }, 0);
        return { teamId, totalScore };
    });
    teamTotals.sort((a, b) => b.totalScore - a.totalScore);
    const topTeams = teamTotals.slice(0, 50).map(t => t.teamId);

    const compressed = {
        t: {},
        m: {
            ...scoresData.metadata,
            teamsKept: topTeams.length
        }
    };

    // For each top team, keep only top 3 players by impact per match
    topTeams.forEach(teamId => {
        compressed.t[teamId] = [];
        scoresData.teams[teamId].forEach(teamObjWithId => {
            const matchId = Object.keys(teamObjWithId)[0];
            const teamObj = teamObjWithId[matchId];
            // Sort players by impact (home runs * 3 + rbi * 2 + doubles + singles)
            const sortedPlayers = Object.entries(teamObj.players || {})
                .sort(([, a], [, b]) => {
                    const aImpact = a.home_runs * 3 + a.rbi * 2 + a.doubles + a.singles;
                    const bImpact = b.home_runs * 3 + b.rbi * 2 + b.doubles + b.singles;
                    return bImpact - aImpact;
                })
                .slice(0, 3); // Keep top 3 players per match
            const compressedTeam = {
                m: matchId,
                h: teamObj.stats.hits,
                e: teamObj.stats.errors,
                s: teamObj.stats.totalscore,
                p: {}
            };
            sortedPlayers.forEach(([playerId, player]) => {
                const totalStats = player.home_runs + player.singles + player.doubles + player.rbi;
                if (totalStats > 0) {
                    compressedTeam.p[playerId] = {
                        hr: player.home_runs,
                        s: player.singles,
                        d: player.doubles,
                        r: player.rbi
                    };
                }
            });
            compressed.t[teamId].push(compressedTeam);
        });
    });

    // Check character count and further compress if needed
    const jsonString = JSON.stringify(compressed);
    if (jsonString.length > maxCharacters) {
        // Optionally, reduce players per team or teams further
        return compressed;
    }

    return compressed;
}

// Function to create a summary format for very large datasets
function createScoresDataSummary(scoresData) {
    if (!scoresData || scoresData.error) {
        return scoresData;
    }

    // Calculate summary statistics
    const teamCount = Object.keys(scoresData.teams).length;
    const playerCount = Object.keys(scoresData.players).length;

    // Top 5 teams by score
    const topTeams = Object.entries(scoresData.teams)
        .sort(([, a], [, b]) => b.stats.totalscore - a.stats.totalscore)
        .slice(0, 5)
        .map(([id, team]) => `${team.name}:${team.stats.totalscore}`);

    // Top 5 players by home runs
    const topPlayers = Object.entries(scoresData.players)
        .sort(([, a], [, b]) => b.stats.home_runs - a.stats.home_runs)
        .slice(0, 5)
        .map(([id, player]) => `${player.name}:${player.stats.home_runs}HR`);

    return {
        summary: {
            teams: teamCount,
            players: playerCount,
            topTeams: topTeams.join(','),
            topPlayers: topPlayers.join(','),
            totalItems: scoresData.metadata.totalItems
        }
    };
}

function formatMLBData(rawData) {
    // Get original data
    const scoresData = formatScoresData(rawData);
    console.log(scoresData.teams['New York Yankees'], scoresData.teams['New York Yankees'].players)
    console.log(scoresData.teams['Los Angeles Dodgers'], scoresData.teams['Los Angeles Dodgers'].players)
    // For OpenAI prompt (under 30k chars)
    const compressed = compressScoresDataForOpenAI(scoresData, 25000);

    console.log(compressed)
    return {
        schedule: formatScheduleData(rawData.schedule),
        standings: formatStandingsData(rawData.standings),
        scores: compressed
    }
}

module.exports = {
    formatMLBData,
    compressScoresDataForOpenAI,
    compressScoresDataForOpenAIAdvanced,
    createScoresDataSummary
};
