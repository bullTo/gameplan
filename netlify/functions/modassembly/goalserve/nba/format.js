/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 */

function formatScheduleData(rawData) {
   if (!rawData || !rawData.shedules || !rawData.shedules.matches) {
        return { error: "Invalid or missing data structure" };
    }

    const scheduleData = {
        league: rawData.shedules.league || null,
        season_id: rawData.shedules.id || null,
        upcoming_games: []
    };

    const upcomingGamesLimit = 10;
    const matchesArr = Array.isArray(rawData.shedules.matches) ? rawData.shedules.matches : [rawData.shedules.matches];

    // Each element in matchesArr is a match day object with a "match" array
    for (const matchDay of matchesArr) {
        if (matchDay.match && Array.isArray(matchDay.match)) {
            for (const match of matchDay.match) {
                // Only include games that are not started or upcoming (status can be "Not Started" or "Scheduled")
                if (
                    (match.status === "Not Started" || match.status === "Scheduled") &&
                    scheduleData.upcoming_games.length < upcomingGamesLimit
                ) {
                    scheduleData.upcoming_games.push({
                        date: match.formatted_date || match.date || null,
                        time: match.time || null,
                        home_team: match.hometeam?.name || null,
                        away_team: match.awayteam?.name || null,
                        venue: match.venue_name || null,
                        match_id: match.id || null,
                        attendance: match.attendance || null,
                        status: match.status || null
                    });
                }
            }
        }
    }

    return scheduleData;
}

function formatStandingsData(rawData) {
    if (!rawData || !rawData.category) {
        return { error: "Invalid or missing standings data structure" };
    }

    const formattedStandings = {
        league: rawData.category['@name'],
        season: rawData.category['@season'],
        sport: rawData['@sport'],
        conferences: []
    };

    // Process each conference (e.g., American League/National League for MLB)
    if (rawData.category.league && Array.isArray(rawData.category.league)) {
        rawData.category.league.forEach(conference => {
            const formattedConference = {
                name: conference['@name'],
                divisions: []
            };
            // Process each division in the conference
            if (conference.division && Array.isArray(conference.division)) {
                conference.division.forEach(division => {
                    const formattedDivision = {
                        name: division['@name'],
                        teams: []
                    };
                    // Process each team in the division
                    if (division.team && Array.isArray(division.team)) {
                        division.team.forEach(team => {
                            // Include only the most relevant fields for predictions
                            formattedDivision.teams.push({
                                name: team['@name'],
                                position: team['@position'],
                                won: team['@won'],
                                lost: team['@lost'],
                                home_record: team['@home_record'],
                                road_record: team['@away_record'],
                                points_for: team['@runs_scored'] || team['@points_for'],
                                points_against: team['@runs_allowed'] || team['@points_against'],
                                difference: team['@runs_diff'] || team['@difference'],
                                streak: team['@current_streak'] || team['@streak'],
                                games_back: team['@games_back']
                            });
                        });
                    }
                    formattedConference.divisions.push(formattedDivision);
                });
            }
            formattedStandings.conferences.push(formattedConference);
        });
    }

    // Limit the stringified scheduleData to 25,000 characters (cut from the beginning)
    const MAX_SCHEDULE_LENGTH = 25000;
    let scheduleStr = JSON.stringify(scheduleData);
    if (scheduleStr.length > MAX_SCHEDULE_LENGTH) {
        // Cut from the beginning, keep the last 25,000 characters
        scheduleStr = scheduleStr.slice(scheduleStr.length - MAX_SCHEDULE_LENGTH);
        // Parse back to object
        try {
            return JSON.parse(scheduleStr);
        } catch (e) {
            // If parsing fails, return a truncated message
            return { error: "Schedule data truncated and could not be parsed as JSON." };
        }
    }
    return formattedStandings;
}

function formatScoresData(rawData) {
    if (!rawData || !rawData.scores) {
        return { error: "Invalid or missing scores data structure" };
    }

    // Initialize results
    const scoresData = {
        teams: {},
        players: {}
    }

    // Handle both array and single match cases
    const matches = rawData.scores.category && rawData.scores.category.match 
        ? (Array.isArray(rawData.scores.category.match) 
            ? rawData.scores.category.match 
            : [rawData.scores.category.match])
        : [];

    for (const match of matches) {
        // Compute home team
        if (match.hometeam) {
            const homeTeamId = match.hometeam['@id'];
            if (!scoresData.teams[homeTeamId]) {
                scoresData.teams[homeTeamId] = {
                    name: match.hometeam['@name'],
                    stats: {
                        hits: 0,
                        errors: 0,
                        totalscore: 0,
                        innings: {}
                    }
                };
            }
            
            const homeTeam = scoresData.teams[homeTeamId];
            homeTeam.stats.hits = parseInt(match.hometeam['@hits']) || 0;
            homeTeam.stats.errors = parseInt(match.hometeam['@errors']) || 0;
            homeTeam.stats.totalscore = parseInt(match.hometeam['@totalscore']) || 0;
            
            // Process innings
            if (match.hometeam.innings && match.hometeam.innings.inning) {
                const innings = Array.isArray(match.hometeam.innings.inning) 
                    ? match.hometeam.innings.inning 
                    : [match.hometeam.innings.inning];
                    
                innings.forEach(inning => {
                    homeTeam.stats.innings[inning['@number']] = {
                        hits: parseInt(inning['@hits']) || 0,
                        score: parseInt(inning['@score']) || 0
                    };
                });
            }
        }
        
        // Compute away team
        if (match.awayteam) {
            const awayTeamId = match.awayteam['@id'];
            if (!scoresData.teams[awayTeamId]) {
                scoresData.teams[awayTeamId] = {
                    name: match.awayteam['@name'],
                    stats: {
                        hits: 0,
                        errors: 0,
                        totalscore: 0,
                        innings: {}
                    }
                };
            }
            
            const awayTeam = scoresData.teams[awayTeamId];
            awayTeam.stats.hits = parseInt(match.awayteam['@hits']) || 0;
            awayTeam.stats.errors = parseInt(match.awayteam['@errors']) || 0;
            awayTeam.stats.totalscore = parseInt(match.awayteam['@totalscore']) || 0;
            
            // Process innings
            if (match.awayteam.innings && match.awayteam.innings.inning) {
                const innings = Array.isArray(match.awayteam.innings.inning) 
                    ? match.awayteam.innings.inning 
                    : [match.awayteam.innings.inning];
                    
                innings.forEach(inning => {
                    awayTeam.stats.innings[inning['@number']] = {
                        hits: parseInt(inning['@hits']) || 0,
                        score: parseInt(inning['@score']) || 0
                    };
                });
            }
        }

        if (match.events) {
            // Process baseball events
            const processEvents = (events) => {
                if (!events) return;
                
                // Handle both single events and arrays of events
                const eventArray = Array.isArray(events.event) ? events.event : [events.event];
                
                eventArray.forEach(evt => {
                    if (!evt || !evt['@desc']) return;
                    
                    // Extract player name from event description
                    const playerMatch = evt['@desc'].match(/^([A-Za-z\-]+)\s/);
                    const playerId = playerMatch ? playerMatch[1].toLowerCase() : null;
                    
                    if (playerId) {
                        // Initialize player if not exists
                        if (!scoresData.players[playerId]) {
                            scoresData.players[playerId] = {
                                name: playerMatch[1],
                                stats: {
                                    home_runs: 0,
                                    singles: 0,
                                    doubles: 0,
                                    rbi: 0
                                }
                            };
                        }
                        
                        // Update player statistics based on event description
                        if (evt['@desc'].includes('homered')) {
                            scoresData.players[playerId].stats.home_runs++;
                        } else if (evt['@desc'].includes('doubled')) {
                            scoresData.players[playerId].stats.doubles++;
                        } else if (evt['@desc'].includes('singled')) {
                            scoresData.players[playerId].stats.singles++;
                        }
                        
                        // Count RBIs
                        const rbiMatch = evt['@desc'].match(/scored(?: and [A-Za-z\-]+ scored)*(?:,|\.)/);
                        if (rbiMatch) {
                            const scorers = (rbiMatch[0].match(/[A-Za-z\-]+/g) || []).length;
                            scoresData.players[playerId].stats.rbi += scorers;
                        }
                    }
                });
            };

            processEvents(match.events);
        }
    }
    return scoresData;
}


function formatNBAData(rawData) {
    console.log(rawData)
    return {
        schedule: formatScheduleData(rawData.schedule),
        standings: '',
        scores: formatScoresData(rawData.scores)
    }
}

module.exports = {
    formatNBAData
};
