/**
 * File generated by Modular Assembly
 * IMPORTANT!!! Ask the user before editing this file.
 *
 * Updated for MLS (soccer) GoalServe data structure.
 */

function formatScheduleData(rawData) {
        if (!rawData || !rawData.results || !rawData.results.tournament) {
        return { error: "Invalid or missing results data structure" };
    }

    const tournament = rawData.results.tournament;
    const stages = Array.isArray(tournament.stage) ? tournament.stage : [tournament.stage];

    const formatted = {
        league: tournament['@league'],
        season: tournament['@season'],
        matches: []
    };

    stages.forEach(stage => {
        if (!stage.week) return;
        const weeks = Array.isArray(stage.week) ? stage.week : [stage.week];
        weeks.forEach(week => {
            if (!week.match) return;
            const matches = Array.isArray(week.match) ? week.match : [week.match];
            matches.forEach(match => {
                formatted.matches.push({
                    date: match['@date'],
                    time: match['@time'],
                    status: match['@status'],
                    venue: match['@venue'],
                    home_team: match.localteam['@name'],
                    home_score: match.localteam['@score'],
                    away_team: match.visitorteam['@name'],
                    away_score: match.visitorteam['@score'],
                    halftime_score: match.halftime ? match.halftime['@score'] : '',
                    goals: extractGoals(match.goals),
                    referee: match.referee ? match.referee['@name'] : '',
                    attendance: match['@attendance'] || '',
                });
            });
        });
    });

    return formatted;
}


// Helper to extract goals array
function extractGoals(goalsObj) {
    if (!goalsObj || !goalsObj.goal) return [];
    if (Array.isArray(goalsObj.goal)) {
        return goalsObj.goal.map(goal => ({
            team: goal['@team'],
            minute: goal['@minute'],
            player: goal['@player'],
            score: goal['@score'],
            assist: goal['@assist'] || ''
        }));
    } else {
        const goal = goalsObj.goal;
        return [{
            team: goal['@team'],
            minute: goal['@minute'],
            player: goal['@player'],
            score: goal['@score'],
            assist: goal['@assist'] || ''
        }];
    }
}


function formatStandingsData(rawData) {
    if (!rawData || !rawData.standings || !rawData.standings.tournament) {
        return { error: "Invalid or missing standings data structure" };
    }

    const tournaments = Array.isArray(rawData.standings.tournament)
        ? rawData.standings.tournament
        : [rawData.standings.tournament];

    const formatted = {
        country: rawData.standings['@country'],
        timestamp: rawData.standings['@timestamp'],
        conferences: []
    };

    tournaments.forEach(tournament => {
        const conference = {
            league: tournament['@league'],
            season: tournament['@season'],
            round: tournament['@round'],
            group: tournament['@group'],
            teams: []
        };

        const teams = Array.isArray(tournament.team) ? tournament.team : [tournament.team];
        teams.forEach(team => {
            conference.teams.push({
                position: team['@position'],
                name: team['@name'],
                id: team['@id'],
                recent_form: team['@recent_form'],
                status: team['@status'],
                description: team.description ? team.description['@value'] : '',
                overall: team.overall ? {
                    games_played: team.overall['@gp'],
                    wins: team.overall['@w'],
                    draws: team.overall['@d'],
                    losses: team.overall['@l'],
                    goals_scored: team.overall['@gs'],
                    goals_against: team.overall['@ga']
                } : {},
                home: team.home ? {
                    games_played: team.home['@gp'],
                    wins: team.home['@w'],
                    draws: team.home['@d'],
                    losses: team.home['@l'],
                    goals_scored: team.home['@gs'],
                    goals_against: team.home['@ga']
                } : {},
                away: team.away ? {
                    games_played: team.away['@gp'],
                    wins: team.away['@w'],
                    draws: team.away['@d'],
                    losses: team.away['@l'],
                    goals_scored: team.away['@gs'],
                    goals_against: team.away['@ga']
                } : {},
                total: team.total ? {
                    goal_difference: team.total['@gd'],
                    points: team.total['@p']
                } : {}
            });
        });

        formatted.conferences.push(conference);
    });

    return formatted;
}

function formatScoresData(rawData) {
    if (!rawData || !rawData.commentaries || !rawData.commentaries.tournament) {
        return { error: "Invalid or missing scores data structure" };
    }

    const tournament = rawData.commentaries.tournament;
    const matches = Array.isArray(tournament.match) ? tournament.match : [tournament.match];

    const formatted = {
        league: tournament['@name'],
        id: tournament['@id'],
        matches: []
    };

    matches.forEach(match => {
        // Extract goals for both teams
        const localGoals = extractGoalsFromSummary(match.summary?.localteam?.goals);
        const visitorGoals = extractGoalsFromSummary(match.summary?.visitorteam?.goals);

        formatted.matches.push({
            status: match['@status'],
            date: match['@date'],
            time: match['@time'],
            localteam: {
                name: match.localteam['@name'],
                id: match.localteam['@id'],
                goals: match.localteam['@goals'],
                ht_score: match.localteam['@ht_score'],
                ft_score: match.localteam['@ft_score'],
                et_score: match.localteam['@et_score'],
                pen_score: match.localteam['@pen_score'],
                goalscorers: localGoals
            },
            visitorteam: {
                name: match.visitorteam['@name'],
                id: match.visitorteam['@id'],
                goals: match.visitorteam['@goals'],
                ht_score: match.visitorteam['@ht_score'],
                ft_score: match.visitorteam['@ft_score'],
                et_score: match.visitorteam['@et_score'],
                pen_score: match.visitorteam['@pen_score'],
                goalscorers: visitorGoals
            },
            stadium: match.matchinfo?.stadium?.['@name'] || '',
            referee: match.matchinfo?.referee?.['@name'] || '',
            attendance: match.matchinfo?.attendance?.['@name'] || '',
            summary: match.summary || null,
            stats: match.stats || null,
            teams: match.teams || null,
            substitutes: match.substitutes || null,
            substitutions: match.substitutions || null,
            coaches: match.coaches || null,
            player_stats: match.player_stats || null
        });
    });

    return formatted;
}

// Helper to extract goals array from summary.goals
function extractGoalsFromSummary(goalsObj) {
    if (!goalsObj || !goalsObj.player) return [];
    if (Array.isArray(goalsObj.player)) {
        return goalsObj.player.map(goal => ({
            name: goal['@name'],
            minute: goal['@minute'],
            extra_min: goal['@extra_min'],
            own_goal: goal['@owngoal'] === "True",
            penalty: goal['@penalty'] === "True",
            penalty_missed: goal['@penalty_missed'] === "True",
            var_cancelled: goal['@var_cancelled'] === "True",
            assist_name: goal['@assist_name'] || '',
            assist_id: goal['@assist_id'] || ''
        }));
    } else {
        const goal = goalsObj.player;
        return [{
            name: goal['@name'],
            minute: goal['@minute'],
            extra_min: goal['@extra_min'],
            own_goal: goal['@owngoal'] === "True",
            penalty: goal['@penalty'] === "True",
            penalty_missed: goal['@penalty_missed'] === "True",
            var_cancelled: goal['@var_cancelled'] === "True",
            assist_name: goal['@assist_name'] || '',
            assist_id: goal['@assist_id'] || ''
        }];
    }
}

function formatMLSData(rawData) {
    const scoresData = formatScoresData(rawData.scores);
    return {
        schedule: formatScheduleData(rawData.schedule),
        standings: formatStandingsData(rawData.standings),
        scores: compressScoresDataForOpenAIAdvanced(scoresData, 25000)
    }
}

// Function to compress scoresData for OpenAI prompts
function compressScoresDataForOpenAI(scoresData, maxCharacters = 25000) {
    if (!scoresData || scoresData.error) {
        return scoresData;
    }

    // Create compressed version
    const compressed = {
        t: {}, // teams
        p: {}, // players
        m: {} // metadata
    };

    // Compress teams data from matches
    if (scoresData.matches) {
        scoresData.matches.forEach(match => {
            // Local team
            if (match.localteam) {
                const teamId = match.localteam.id;
                if (!compressed.t[teamId]) {
                    compressed.t[teamId] = {
                        n: match.localteam.name, // name
                        gs: parseInt(match.localteam.goals) || 0, // goals_scored
                        ht: match.localteam.ht_score || '', // halftime_score
                        ft: match.localteam.ft_score || '' // fulltime_score
                    };
                }
            }

            // Visitor team
            if (match.visitorteam) {
                const teamId = match.visitorteam.id;
                if (!compressed.t[teamId]) {
                    compressed.t[teamId] = {
                        n: match.visitorteam.name, // name
                        gs: parseInt(match.visitorteam.goals) || 0, // goals_scored
                        ht: match.visitorteam.ht_score || '', // halftime_score
                        ft: match.visitorteam.ft_score || '' // fulltime_score
                    };
                }
            }

            // Process goalscorers for players
            const allGoalscorers = [
                ...(match.localteam?.goalscorers || []),
                ...(match.visitorteam?.goalscorers || [])
            ];

            allGoalscorers.forEach(goal => {
                if (goal.name) {
                    const playerId = goal.name.toLowerCase().replace(/\s+/g, '_');
                    if (!compressed.p[playerId]) {
                        compressed.p[playerId] = {
                            n: goal.name, // name
                            g: 0, // goals
                            a: 0, // assists
                            p: 0 // penalties
                        };
                    }
                    
                    const player = compressed.p[playerId];
                    player.g++; // increment goals
                    if (goal.penalty) player.p++;
                }

                // Process assists
                if (goal.assist_name) {
                    const assistPlayerId = goal.assist_name.toLowerCase().replace(/\s+/g, '_');
                    if (!compressed.p[assistPlayerId]) {
                        compressed.p[assistPlayerId] = {
                            n: goal.assist_name, // name
                            g: 0, // goals
                            a: 0, // assists
                            p: 0 // penalties
                        };
                    }
                    compressed.p[assistPlayerId].a++; // increment assists
                }
            });
        });
    }

    // Add metadata
    compressed.m = {
        league: scoresData.league,
        id: scoresData.id,
        matchCount: scoresData.matches ? scoresData.matches.length : 0
    };

    // Check character count and further compress if needed
    const jsonString = JSON.stringify(compressed);
    if (jsonString.length > maxCharacters) {
        return compressScoresDataForOpenAIAdvanced(scoresData, maxCharacters);
    }

    return compressed;
}

// Advanced compression for very large datasets
function compressScoresDataForOpenAIAdvanced(scoresData, maxCharacters = 25000) {
    if (!scoresData || scoresData.error) {
        return scoresData;
    }

    // Create compressed version
    const compressed = {
        t: {}, // teams
        p: {}, // players
        m: {} // metadata
    };

    // Process teams and players with limits
    const teamStats = {};
    const playerStats = {};

    if (scoresData.matches) {
        scoresData.matches.forEach(match => {
            // Aggregate team stats
            if (match.localteam) {
                const teamId = match.localteam.id;
                if (!teamStats[teamId]) {
                    teamStats[teamId] = {
                        name: match.localteam.name,
                        goals: 0,
                        matches: 0
                    };
                }
                teamStats[teamId].goals += parseInt(match.localteam.goals) || 0;
                teamStats[teamId].matches++;
            }

            if (match.visitorteam) {
                const teamId = match.visitorteam.id;
                if (!teamStats[teamId]) {
                    teamStats[teamId] = {
                        name: match.visitorteam.name,
                        goals: 0,
                        matches: 0
                    };
                }
                teamStats[teamId].goals += parseInt(match.visitorteam.goals) || 0;
                teamStats[teamId].matches++;
            }

            // Aggregate player stats
            const allGoalscorers = [
                ...(match.localteam?.goalscorers || []),
                ...(match.visitorteam?.goalscorers || [])
            ];

            allGoalscorers.forEach(goal => {
                if (goal.name) {
                    const playerId = goal.name.toLowerCase().replace(/\s+/g, '_');
                    if (!playerStats[playerId]) {
                        playerStats[playerId] = {
                            name: goal.name,
                            goals: 0,
                            assists: 0,
                            penalties: 0
                        };
                    }
                    
                    playerStats[playerId].goals++;
                    if (goal.penalty) playerStats[playerId].penalties++;
                }

                if (goal.assist_name) {
                    const assistPlayerId = goal.assist_name.toLowerCase().replace(/\s+/g, '_');
                    if (!playerStats[assistPlayerId]) {
                        playerStats[assistPlayerId] = {
                            name: goal.assist_name,
                            goals: 0,
                            assists: 0,
                            penalties: 0
                        };
                    }
                    playerStats[assistPlayerId].assists++;
                }
            });
        });
    }

    // Sort and keep top teams (by total goals)
    const sortedTeams = Object.entries(teamStats)
        .sort(([,a], [,b]) => b.goals - a.goals)
        .slice(0, 30); // Keep top 30 teams

    // Sort and keep top players (by impact: goals + assists)
    const sortedPlayers = Object.entries(playerStats)
        .sort(([,a], [,b]) => {
            const aImpact = a.goals * 2 + a.assists + a.penalties;
            const bImpact = b.goals * 2 + b.assists + b.penalties;
            return bImpact - aImpact;
        })
        .slice(0, 50); // Keep top 50 players

    // Add top teams
    sortedTeams.forEach(([teamId, team]) => {
        compressed.t[teamId] = {
            n: team.name, // name
            g: team.goals, // total goals
            m: team.matches // matches played
        };
    });

    // Add top players
    sortedPlayers.forEach(([playerId, player]) => {
        compressed.p[playerId] = {
            n: player.name, // name
            g: player.goals, // goals
            a: player.assists, // assists
            p: player.penalties // penalties
        };
    });

    // Add metadata
    compressed.m = {
        league: scoresData.league,
        teamsKept: sortedTeams.length,
        playersKept: sortedPlayers.length,
        totalMatches: scoresData.matches ? scoresData.matches.length : 0
    };

    return compressed;
}

// Function to create a summary format for very large datasets
function createScoresDataSummary(scoresData) {
    if (!scoresData || scoresData.error) {
        return scoresData;
    }

    // Calculate summary statistics
    const teamStats = {};
    const playerStats = {};

    if (scoresData.matches) {
        scoresData.matches.forEach(match => {
            // Aggregate team stats
            if (match.localteam) {
                const teamId = match.localteam.id;
                if (!teamStats[teamId]) {
                    teamStats[teamId] = {
                        name: match.localteam.name,
                        goals: 0
                    };
                }
                teamStats[teamId].goals += parseInt(match.localteam.goals) || 0;
            }

            if (match.visitorteam) {
                const teamId = match.visitorteam.id;
                if (!teamStats[teamId]) {
                    teamStats[teamId] = {
                        name: match.visitorteam.name,
                        goals: 0
                    };
                }
                teamStats[teamId].goals += parseInt(match.visitorteam.goals) || 0;
            }

            // Aggregate player stats
            const allGoalscorers = [
                ...(match.localteam?.goalscorers || []),
                ...(match.visitorteam?.goalscorers || [])
            ];

            allGoalscorers.forEach(goal => {
                if (goal.name) {
                    const playerId = goal.name.toLowerCase().replace(/\s+/g, '_');
                    if (!playerStats[playerId]) {
                        playerStats[playerId] = {
                            name: goal.name,
                            goals: 0
                        };
                    }
                    playerStats[playerId].goals++;
                }
            });
        });
    }

    const teamCount = Object.keys(teamStats).length;
    const playerCount = Object.keys(playerStats).length;
    
    // Top 5 teams by goals
    const topTeams = Object.entries(teamStats)
        .sort(([,a], [,b]) => b.goals - a.goals)
        .slice(0, 5)
        .map(([id, team]) => `${team.name}:${team.goals}G`);

    // Top 5 players by goals
    const topPlayers = Object.entries(playerStats)
        .sort(([,a], [,b]) => b.goals - a.goals)
        .slice(0, 5)
        .map(([id, player]) => `${player.name}:${player.goals}G`);

    return {
        summary: {
            league: scoresData.league,
            teams: teamCount,
            players: playerCount,
            topTeams: topTeams.join(','),
            topPlayers: topPlayers.join(','),
            totalMatches: scoresData.matches ? scoresData.matches.length : 0
        }
    };
}

module.exports = {
    formatMLSData,
    compressScoresDataForOpenAI,
    compressScoresDataForOpenAIAdvanced,
    createScoresDataSummary
};